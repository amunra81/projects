<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.Csv.Streaming</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-Csv-Streaming.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">cassava-0.4.2.4: A CSV parsing and encoding library</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.Csv.Streaming</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Usage example</a></li><li><a href="#g:2">Stream representation</a></li><li><a href="#g:3">Decoding records</a><ul><li><a href="#g:4">Index-based record conversion</a></li><li><a href="#g:5">Name-based record conversion</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module allows for streaming decoding of CSV data. This is
 useful if you need to parse large amounts of input in constant
 space. The API also allows you to ignore type conversion errors on
 a per-record basis.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:Records">Records</a> a<ul class="subs"><li>= <a href="#v:Cons">Cons</a> (<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> a) (<a href="Data-Csv-Streaming.html#t:Records">Records</a> a)</li><li>| <a href="#v:Nil">Nil</a> (<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a>) ByteString</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:HasHeader">HasHeader</a><ul class="subs"><li>= <a href="#v:HasHeader">HasHeader</a></li><li>| <a href="#v:NoHeader">NoHeader</a></li></ul></li><li class="src short"><a href="#v:decode">decode</a> :: <a href="Data-Csv.html#t:FromRecord">FromRecord</a> a =&gt; <a href="Data-Csv-Streaming.html#t:HasHeader">HasHeader</a> -&gt; ByteString -&gt; <a href="Data-Csv-Streaming.html#t:Records">Records</a> a</li><li class="src short"><a href="#v:decodeWith">decodeWith</a> :: <a href="Data-Csv.html#t:FromRecord">FromRecord</a> a =&gt; <a href="Data-Csv-Parser.html#t:DecodeOptions">DecodeOptions</a> -&gt; <a href="Data-Csv-Streaming.html#t:HasHeader">HasHeader</a> -&gt; ByteString -&gt; <a href="Data-Csv-Streaming.html#t:Records">Records</a> a</li><li class="src short"><a href="#v:decodeByName">decodeByName</a> :: <a href="Data-Csv.html#t:FromNamedRecord">FromNamedRecord</a> a =&gt; ByteString -&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (<a href="Data-Csv.html#t:Header">Header</a>, <a href="Data-Csv-Streaming.html#t:Records">Records</a> a)</li><li class="src short"><a href="#v:decodeByNameWith">decodeByNameWith</a> :: <a href="Data-Csv.html#t:FromNamedRecord">FromNamedRecord</a> a =&gt; <a href="Data-Csv-Parser.html#t:DecodeOptions">DecodeOptions</a> -&gt; ByteString -&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (<a href="Data-Csv.html#t:Header">Header</a>, <a href="Data-Csv-Streaming.html#t:Records">Records</a> a)</li></ul></div><div id="interface"><h1 id="g:1">Usage example</h1><div class="doc"><p>A short usage example:</p><pre>for_ (decode NoHeader &quot;John,27\r\nJane,28\r\n&quot;) $ \ (name, age :: Int) -&gt;
    putStrLn $ name ++ &quot; is &quot; ++ show age ++ &quot; years old&quot;</pre><p>N.B. The <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Foldable.html#t:Foldable">Foldable</a></code> instance, which is used above, skips records
 that failed to convert. If you don't want this behavior, work
 directly with the <code><a href="Data-Csv-Streaming.html#v:Cons">Cons</a></code> and <code><a href="Data-Csv-Streaming.html#v:Nil">Nil</a></code> constructors.</p></div><h1 id="g:2">Stream representation</h1><div class="doc"><p>A stream of records is represented as a (lazy) list that may
 contain errors.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Records" class="def">Records</a> a</p><div class="doc"><p>A stream of parsed records. If type conversion failed for the
 record, the error is returned as <code><code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Left">Left</a></code> errMsg</code>.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Cons" class="def">Cons</a> (<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> a) (<a href="Data-Csv-Streaming.html#t:Records">Records</a> a)</td><td class="doc"><p>A record or an error message, followed by more records.</p></td></tr><tr><td class="src"><a name="v:Nil" class="def">Nil</a> (<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a>) ByteString</td><td class="doc"><p>End of stream, potentially due to a parse error. If a parse
 error occured, the first field contains the error message.
 The second field contains any unconsumed input.</p></td></tr></table></div><div class="subs instances"><p id="control.i:Records" class="caption collapser" onclick="toggleSection('i:Records')">Instances</p><div id="section.i:Records" class="show"><table><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Functor">Functor</a> <a href="Data-Csv-Streaming.html#t:Records">Records</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Foldable.html#t:Foldable">Foldable</a> <a href="Data-Csv-Streaming.html#t:Records">Records</a></td><td class="doc"><p>Skips records that failed to convert.</p></td></tr><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Traversable.html#t:Traversable">Traversable</a> <a href="Data-Csv-Streaming.html#t:Records">Records</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Eq.html#t:Eq">Eq</a> a =&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Eq.html#t:Eq">Eq</a> (<a href="Data-Csv-Streaming.html#t:Records">Records</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> a =&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> (<a href="Data-Csv-Streaming.html#t:Records">Records</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/deepseq-1.3.0.2/Control-DeepSeq.html#t:NFData">NFData</a> a =&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/deepseq-1.3.0.2/Control-DeepSeq.html#t:NFData">NFData</a> (<a href="Data-Csv-Streaming.html#t:Records">Records</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:3">Decoding records</h1><div class="doc"><p>Just like in the case of non-streaming decoding, there are two ways
 to convert CSV records to and from and user-defined data types:
 index-based conversion and name-based conversion.</p></div><h2 id="g:4">Index-based record conversion</h2><div class="doc"><p>See documentation on index-based conversion in <a href="Data-Csv.html">Data.Csv</a> for more
 information.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:HasHeader" class="def">HasHeader</a></p><div class="doc"><p>Is the CSV data preceded by a header?</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HasHeader" class="def">HasHeader</a></td><td class="doc"><p>The CSV data is preceded by a header</p></td></tr><tr><td class="src"><a name="v:NoHeader" class="def">NoHeader</a></td><td class="doc"><p>The CSV data is not preceded by a header</p></td></tr></table></div></div><div class="top"><p class="src"><a name="v:decode" class="def">decode</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Data-Csv.html#t:FromRecord">FromRecord</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Data-Csv-Streaming.html#t:HasHeader">HasHeader</a></td><td class="doc"><p>Data contains header that should be
 skipped</p></td></tr><tr><td class="src">-&gt; ByteString</td><td class="doc"><p>CSV data</p></td></tr><tr><td class="src">-&gt; <a href="Data-Csv-Streaming.html#t:Records">Records</a> a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Efficiently deserialize CSV records in a streaming fashion.
 Equivalent to <code><code><a href="Data-Csv-Streaming.html#v:decodeWith">decodeWith</a></code> <code><a href="Data-Csv-Parser.html#v:defaultDecodeOptions">defaultDecodeOptions</a></code></code>.</p></div></div><div class="top"><p class="src"><a name="v:decodeWith" class="def">decodeWith</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Data-Csv.html#t:FromRecord">FromRecord</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Data-Csv-Parser.html#t:DecodeOptions">DecodeOptions</a></td><td class="doc"><p>Decoding options</p></td></tr><tr><td class="src">-&gt; <a href="Data-Csv-Streaming.html#t:HasHeader">HasHeader</a></td><td class="doc"><p>Data contains header that should be
 skipped</p></td></tr><tr><td class="src">-&gt; ByteString</td><td class="doc"><p>CSV data</p></td></tr><tr><td class="src">-&gt; <a href="Data-Csv-Streaming.html#t:Records">Records</a> a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="Data-Csv-Streaming.html#v:decode">decode</a></code>, but lets you customize how the CSV data is parsed.</p></div></div><h2 id="g:5">Name-based record conversion</h2><div class="doc"><p>See documentation on name-based conversion in <a href="Data-Csv.html">Data.Csv</a> for more
 information.</p></div><div class="top"><p class="src"><a name="v:decodeByName" class="def">decodeByName</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Data-Csv.html#t:FromNamedRecord">FromNamedRecord</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; ByteString</td><td class="doc"><p>CSV data</p></td></tr><tr><td class="src">-&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (<a href="Data-Csv.html#t:Header">Header</a>, <a href="Data-Csv-Streaming.html#t:Records">Records</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Efficiently deserialize CSV in a streaming fashion. The data is
 assumed to be preceeded by a header. Returns <code><code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Left">Left</a></code> errMsg</code> if
 parsing the header fails. Equivalent to <code><code><a href="Data-Csv-Streaming.html#v:decodeByNameWith">decodeByNameWith</a></code>
 <code><a href="Data-Csv-Parser.html#v:defaultDecodeOptions">defaultDecodeOptions</a></code></code>.</p></div></div><div class="top"><p class="src"><a name="v:decodeByNameWith" class="def">decodeByNameWith</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Data-Csv.html#t:FromNamedRecord">FromNamedRecord</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Data-Csv-Parser.html#t:DecodeOptions">DecodeOptions</a></td><td class="doc"><p>Decoding options</p></td></tr><tr><td class="src">-&gt; ByteString</td><td class="doc"><p>CSV data</p></td></tr><tr><td class="src">-&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (<a href="Data-Csv.html#t:Header">Header</a>, <a href="Data-Csv-Streaming.html#t:Records">Records</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="Data-Csv-Streaming.html#v:decodeByName">decodeByName</a></code>, but lets you customize how the CSV data is
 parsed.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>