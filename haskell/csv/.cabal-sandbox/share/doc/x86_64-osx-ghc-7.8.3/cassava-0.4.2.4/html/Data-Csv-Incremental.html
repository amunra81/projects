<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.Csv.Incremental</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-Csv-Incremental.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">cassava-0.4.2.4: A CSV parsing and encoding library</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.Csv.Incremental</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Decoding headers</a></li><li><a href="#g:2">Decoding records</a><ul><li><a href="#g:3">Index-based record conversion</a></li><li><a href="#g:4">Name-based record conversion</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module allows for incremental decoding of CSV data. This is
 useful if you e.g. want to interleave I/O with parsing or if you
 want finer grained control over how you deal with type conversion
 errors.</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:HeaderParser">HeaderParser</a> a<ul class="subs"><li>= <a href="#v:FailH">FailH</a> !ByteString <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a></li><li>| <a href="#v:PartialH">PartialH</a> (ByteString -&gt; <a href="Data-Csv-Incremental.html#t:HeaderParser">HeaderParser</a> a)</li><li>| <a href="#v:DoneH">DoneH</a> !<a href="Data-Csv.html#t:Header">Header</a> a</li></ul></li><li class="src short"><a href="#v:decodeHeader">decodeHeader</a> :: <a href="Data-Csv-Incremental.html#t:HeaderParser">HeaderParser</a> ByteString</li><li class="src short"><a href="#v:decodeHeaderWith">decodeHeaderWith</a> :: <a href="Data-Csv-Parser.html#t:DecodeOptions">DecodeOptions</a> -&gt; <a href="Data-Csv-Incremental.html#t:HeaderParser">HeaderParser</a> ByteString</li><li class="src short"><span class="keyword">data</span> <a href="#t:Parser">Parser</a> a<ul class="subs"><li>= <a href="#v:Fail">Fail</a> !ByteString <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a></li><li>| <a href="#v:Many">Many</a> [<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> a] (ByteString -&gt; <a href="Data-Csv-Incremental.html#t:Parser">Parser</a> a)</li><li>| <a href="#v:Done">Done</a> [<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> a]</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:HasHeader">HasHeader</a><ul class="subs"><li>= <a href="#v:HasHeader">HasHeader</a></li><li>| <a href="#v:NoHeader">NoHeader</a></li></ul></li><li class="src short"><a href="#v:decode">decode</a> :: <a href="Data-Csv.html#t:FromRecord">FromRecord</a> a =&gt; <a href="Data-Csv-Incremental.html#t:HasHeader">HasHeader</a> -&gt; <a href="Data-Csv-Incremental.html#t:Parser">Parser</a> a</li><li class="src short"><a href="#v:decodeWith">decodeWith</a> :: <a href="Data-Csv.html#t:FromRecord">FromRecord</a> a =&gt; <a href="Data-Csv-Parser.html#t:DecodeOptions">DecodeOptions</a> -&gt; <a href="Data-Csv-Incremental.html#t:HasHeader">HasHeader</a> -&gt; <a href="Data-Csv-Incremental.html#t:Parser">Parser</a> a</li><li class="src short"><a href="#v:decodeByName">decodeByName</a> :: <a href="Data-Csv.html#t:FromNamedRecord">FromNamedRecord</a> a =&gt; <a href="Data-Csv-Incremental.html#t:HeaderParser">HeaderParser</a> (<a href="Data-Csv-Incremental.html#t:Parser">Parser</a> a)</li><li class="src short"><a href="#v:decodeByNameWith">decodeByNameWith</a> :: <a href="Data-Csv.html#t:FromNamedRecord">FromNamedRecord</a> a =&gt; <a href="Data-Csv-Parser.html#t:DecodeOptions">DecodeOptions</a> -&gt; <a href="Data-Csv-Incremental.html#t:HeaderParser">HeaderParser</a> (<a href="Data-Csv-Incremental.html#t:Parser">Parser</a> a)</li></ul></div><div id="interface"><h1 id="g:1">Decoding headers</h1><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:HeaderParser" class="def">HeaderParser</a> a</p><div class="doc"><p>An incremental parser that when fed data eventually returns a
 parsed <code><a href="Data-Csv.html#t:Header">Header</a></code>, or an error.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:FailH" class="def">FailH</a> !ByteString <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a></td><td class="doc"><p>The input data was malformed. The first field contains any
 unconsumed input and second field contains information about
 the parse error.</p></td></tr><tr><td class="src"><a name="v:PartialH" class="def">PartialH</a> (ByteString -&gt; <a href="Data-Csv-Incremental.html#t:HeaderParser">HeaderParser</a> a)</td><td class="doc"><p>The parser needs more input data before it can produce a
 result. Use an <code>empty</code> string to indicate that no more
 input data is available. If fed an 'B.empty string', the
 continuation is guaranteed to return either <code><a href="Data-Csv-Incremental.html#v:FailH">FailH</a></code> or
 <code><a href="Data-Csv-Incremental.html#v:DoneH">DoneH</a></code>.</p></td></tr><tr><td class="src"><a name="v:DoneH" class="def">DoneH</a> !<a href="Data-Csv.html#t:Header">Header</a> a</td><td class="doc"><p>The parse succeeded and produced the given <code><a href="Data-Csv.html#t:Header">Header</a></code>.</p></td></tr></table></div><div class="subs instances"><p id="control.i:HeaderParser" class="caption collapser" onclick="toggleSection('i:HeaderParser')">Instances</p><div id="section.i:HeaderParser" class="show"><table><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Functor">Functor</a> <a href="Data-Csv-Incremental.html#t:HeaderParser">HeaderParser</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> a =&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> (<a href="Data-Csv-Incremental.html#t:HeaderParser">HeaderParser</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:decodeHeader" class="def">decodeHeader</a> :: <a href="Data-Csv-Incremental.html#t:HeaderParser">HeaderParser</a> ByteString</p><div class="doc"><p>Parse a CSV header in an incremental fashion. When done, the
 <code><a href="Data-Csv-Incremental.html#t:HeaderParser">HeaderParser</a></code> returns any unconsumed input in the second field of
 the <code><a href="Data-Csv-Incremental.html#v:DoneH">DoneH</a></code> constructor.</p></div></div><div class="top"><p class="src"><a name="v:decodeHeaderWith" class="def">decodeHeaderWith</a> :: <a href="Data-Csv-Parser.html#t:DecodeOptions">DecodeOptions</a> -&gt; <a href="Data-Csv-Incremental.html#t:HeaderParser">HeaderParser</a> ByteString</p><div class="doc"><p>Like <code><a href="Data-Csv-Incremental.html#v:decodeHeader">decodeHeader</a></code>, but lets you customize how the CSV data is
 parsed.</p></div></div><h1 id="g:2">Decoding records</h1><div class="doc"><p>Just like in the case of non-incremental decoding, there are two
 ways to convert CSV records to and from and user-defined data
 types: index-based conversion and name-based conversion.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Parser" class="def">Parser</a> a</p><div class="doc"><p>An incremental parser that when fed data eventually produces some
 parsed records, converted to the desired type, or an error in case
 of malformed input data.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Fail" class="def">Fail</a> !ByteString <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a></td><td class="doc"><p>The input data was malformed. The first field contains any
 unconsumed input and second field contains information about
 the parse error.</p></td></tr><tr><td class="src"><a name="v:Many" class="def">Many</a> [<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> a] (ByteString -&gt; <a href="Data-Csv-Incremental.html#t:Parser">Parser</a> a)</td><td class="doc"><p>The parser parsed and converted zero or more records. Any
 records that failed type conversion are returned as <code><code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Left">Left</a></code>
 errMsg</code> and the rest as <code><code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Right">Right</a></code> val</code>. Feed a <code>ByteString</code>
 to the continuation to continue parsing. Use an <code>empty</code>
 string to indicate that no more input data is available. If
 fed an <code>empty</code> string, the continuation is guaranteed to
 return either <code><a href="Data-Csv-Incremental.html#v:Fail">Fail</a></code> or <code><a href="Data-Csv-Incremental.html#v:Done">Done</a></code>.</p></td></tr><tr><td class="src"><a name="v:Done" class="def">Done</a> [<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> a]</td><td class="doc"><p>The parser parsed and converted some records. Any records
 that failed type conversion are returned as <code><code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Left">Left</a></code> errMsg</code>
 and the rest as <code><code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Right">Right</a></code> val</code>.</p></td></tr></table></div><div class="subs instances"><p id="control.i:Parser" class="caption collapser" onclick="toggleSection('i:Parser')">Instances</p><div id="section.i:Parser" class="show"><table><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Functor">Functor</a> <a href="Data-Csv-Incremental.html#t:Parser">Parser</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> a =&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> (<a href="Data-Csv-Incremental.html#t:Parser">Parser</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:3">Index-based record conversion</h2><div class="doc"><p>See documentation on index-based conversion in <a href="Data-Csv.html">Data.Csv</a> for more
 information.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:HasHeader" class="def">HasHeader</a></p><div class="doc"><p>Is the CSV data preceded by a header?</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HasHeader" class="def">HasHeader</a></td><td class="doc"><p>The CSV data is preceded by a header</p></td></tr><tr><td class="src"><a name="v:NoHeader" class="def">NoHeader</a></td><td class="doc"><p>The CSV data is not preceded by a header</p></td></tr></table></div></div><div class="top"><p class="src"><a name="v:decode" class="def">decode</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Data-Csv.html#t:FromRecord">FromRecord</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Data-Csv-Incremental.html#t:HasHeader">HasHeader</a></td><td class="doc"><p>Data contains header that should be
 skipped</p></td></tr><tr><td class="src">-&gt; <a href="Data-Csv-Incremental.html#t:Parser">Parser</a> a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Efficiently deserialize CSV in an incremental fashion. Equivalent
 to <code><code><a href="Data-Csv-Incremental.html#v:decodeWith">decodeWith</a></code> <code><a href="Data-Csv-Parser.html#v:defaultDecodeOptions">defaultDecodeOptions</a></code></code>.</p></div></div><div class="top"><p class="src"><a name="v:decodeWith" class="def">decodeWith</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Data-Csv.html#t:FromRecord">FromRecord</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Data-Csv-Parser.html#t:DecodeOptions">DecodeOptions</a></td><td class="doc"><p>Decoding options</p></td></tr><tr><td class="src">-&gt; <a href="Data-Csv-Incremental.html#t:HasHeader">HasHeader</a></td><td class="doc"><p>Data contains header that should be
 skipped</p></td></tr><tr><td class="src">-&gt; <a href="Data-Csv-Incremental.html#t:Parser">Parser</a> a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="Data-Csv-Incremental.html#v:decode">decode</a></code>, but lets you customize how the CSV data is parsed.</p></div></div><h2 id="g:4">Name-based record conversion</h2><div class="doc"><p>See documentation on name-based conversion in <a href="Data-Csv.html">Data.Csv</a> for more
 information.</p></div><div class="top"><p class="src"><a name="v:decodeByName" class="def">decodeByName</a> :: <a href="Data-Csv.html#t:FromNamedRecord">FromNamedRecord</a> a =&gt; <a href="Data-Csv-Incremental.html#t:HeaderParser">HeaderParser</a> (<a href="Data-Csv-Incremental.html#t:Parser">Parser</a> a)</p><div class="doc"><p>Efficiently deserialize CSV in an incremental fashion. The data
 is assumed to be preceeded by a header. Returns a <code><a href="Data-Csv-Incremental.html#t:HeaderParser">HeaderParser</a></code>
 that when done produces a <code><a href="Data-Csv-Incremental.html#t:Parser">Parser</a></code> for parsing the actual records.
 Equivalent to <code><code><a href="Data-Csv-Incremental.html#v:decodeByNameWith">decodeByNameWith</a></code> <code><a href="Data-Csv-Parser.html#v:defaultDecodeOptions">defaultDecodeOptions</a></code></code>.</p></div></div><div class="top"><p class="src"><a name="v:decodeByNameWith" class="def">decodeByNameWith</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Data-Csv.html#t:FromNamedRecord">FromNamedRecord</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Data-Csv-Parser.html#t:DecodeOptions">DecodeOptions</a></td><td class="doc"><p>Decoding options</p></td></tr><tr><td class="src">-&gt; <a href="Data-Csv-Incremental.html#t:HeaderParser">HeaderParser</a> (<a href="Data-Csv-Incremental.html#t:Parser">Parser</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="Data-Csv-Incremental.html#v:decodeByName">decodeByName</a></code>, but lets you customize how the CSV data is
 parsed.</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>