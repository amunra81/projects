<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Data.Csv</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Data-Csv.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">cassava-0.4.2.4: A CSV parsing and encoding library</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Data.Csv</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Usage example</a></li><li><a href="#g:2">Treating CSV data as opaque byte strings</a></li><li><a href="#g:3">Custom type conversions</a><ul><li><a href="#g:4">Dealing with bad data</a></li></ul></li><li><a href="#g:5">Encoding and decoding</a><ul><li><a href="#g:6">Encoding and decoding options</a></li></ul></li><li><a href="#g:7">Core CSV types</a></li><li><a href="#g:8">Type conversion</a><ul><li><a href="#g:9">Index-based record conversion</a></li><li><a href="#g:10">Name-based record conversion</a></li><li><a href="#g:11">Field conversion</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module implements encoding and decoding of CSV data. The
 implementation is RFC 4180 compliant, with the following
 extensions:</p><ul><li>Empty lines are ignored.</li><li>Non-escaped fields may contain any characters except
    double-quotes, commas, carriage returns, and newlines.</li><li>Escaped fields may contain any characters (but double-quotes
    need to be escaped).</li></ul></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span> <a href="#t:HasHeader">HasHeader</a><ul class="subs"><li>= <a href="#v:HasHeader">HasHeader</a></li><li>| <a href="#v:NoHeader">NoHeader</a></li></ul></li><li class="src short"><a href="#v:decode">decode</a> :: <a href="Data-Csv.html#t:FromRecord">FromRecord</a> a =&gt; <a href="Data-Csv.html#t:HasHeader">HasHeader</a> -&gt; ByteString -&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (Vector a)</li><li class="src short"><a href="#v:decodeByName">decodeByName</a> :: <a href="Data-Csv.html#t:FromNamedRecord">FromNamedRecord</a> a =&gt; ByteString -&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (<a href="Data-Csv.html#t:Header">Header</a>, Vector a)</li><li class="src short"><a href="#v:encode">encode</a> :: <a href="Data-Csv.html#t:ToRecord">ToRecord</a> a =&gt; [a] -&gt; ByteString</li><li class="src short"><a href="#v:encodeByName">encodeByName</a> :: <a href="Data-Csv.html#t:ToNamedRecord">ToNamedRecord</a> a =&gt; <a href="Data-Csv.html#t:Header">Header</a> -&gt; [a] -&gt; ByteString</li><li class="src short"><span class="keyword">data</span> <a href="#t:DecodeOptions">DecodeOptions</a> = <a href="#v:DecodeOptions">DecodeOptions</a> {<ul class="subs"><li><a href="#v:decDelimiter">decDelimiter</a> :: !<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Word.html#t:Word8">Word8</a></li></ul>}</li><li class="src short"><a href="#v:defaultDecodeOptions">defaultDecodeOptions</a> :: <a href="Data-Csv.html#t:DecodeOptions">DecodeOptions</a></li><li class="src short"><a href="#v:decodeWith">decodeWith</a> :: <a href="Data-Csv.html#t:FromRecord">FromRecord</a> a =&gt; <a href="Data-Csv.html#t:DecodeOptions">DecodeOptions</a> -&gt; <a href="Data-Csv.html#t:HasHeader">HasHeader</a> -&gt; ByteString -&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (Vector a)</li><li class="src short"><a href="#v:decodeByNameWith">decodeByNameWith</a> :: <a href="Data-Csv.html#t:FromNamedRecord">FromNamedRecord</a> a =&gt; <a href="Data-Csv.html#t:DecodeOptions">DecodeOptions</a> -&gt; ByteString -&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (<a href="Data-Csv.html#t:Header">Header</a>, Vector a)</li><li class="src short"><span class="keyword">data</span> <a href="#t:EncodeOptions">EncodeOptions</a> = <a href="#v:EncodeOptions">EncodeOptions</a> {<ul class="subs"><li><a href="#v:encDelimiter">encDelimiter</a> :: !<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Word.html#t:Word8">Word8</a></li><li><a href="#v:encUseCrLf">encUseCrLf</a> :: !<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Bool.html#t:Bool">Bool</a></li><li><a href="#v:encIncludeHeader">encIncludeHeader</a> :: !<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Bool.html#t:Bool">Bool</a></li></ul>}</li><li class="src short"><a href="#v:defaultEncodeOptions">defaultEncodeOptions</a> :: <a href="Data-Csv.html#t:EncodeOptions">EncodeOptions</a></li><li class="src short"><a href="#v:encodeWith">encodeWith</a> :: <a href="Data-Csv.html#t:ToRecord">ToRecord</a> a =&gt; <a href="Data-Csv.html#t:EncodeOptions">EncodeOptions</a> -&gt; [a] -&gt; ByteString</li><li class="src short"><a href="#v:encodeByNameWith">encodeByNameWith</a> :: <a href="Data-Csv.html#t:ToNamedRecord">ToNamedRecord</a> a =&gt; <a href="Data-Csv.html#t:EncodeOptions">EncodeOptions</a> -&gt; <a href="Data-Csv.html#t:Header">Header</a> -&gt; [a] -&gt; ByteString</li><li class="src short"><span class="keyword">type</span> <a href="#t:Csv">Csv</a> = Vector <a href="Data-Csv.html#t:Record">Record</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Record">Record</a> = Vector <a href="Data-Csv.html#t:Field">Field</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Field">Field</a> = ByteString</li><li class="src short"><span class="keyword">type</span> <a href="#t:Header">Header</a> = Vector <a href="Data-Csv.html#t:Name">Name</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Name">Name</a> = ByteString</li><li class="src short"><span class="keyword">type</span> <a href="#t:NamedRecord">NamedRecord</a> = <a href="file:///Users/horus/projects/haskell/csv/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/unordered-containers-0.2.5.1/html/Data-HashMap-Strict.html#t:HashMap">HashMap</a> ByteString ByteString</li><li class="src short"><span class="keyword">class</span> <a href="#t:FromRecord">FromRecord</a> a <span class="keyword">where</span><ul class="subs"><li><a href="#v:parseRecord">parseRecord</a> :: <a href="Data-Csv.html#t:Record">Record</a> -&gt; <a href="Data-Csv.html#t:Parser">Parser</a> a</li></ul></li><li class="src short"><span class="keyword">data</span> <a href="#t:Parser">Parser</a> a</li><li class="src short"><a href="#v:runParser">runParser</a> ::  <a href="Data-Csv.html#t:Parser">Parser</a> a -&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> a</li><li class="src short"><a href="#v:index">index</a> :: <a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:Record">Record</a> -&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="Data-Csv.html#t:Parser">Parser</a> a</li><li class="src short"><a href="#v:.-33-">(.!)</a> :: <a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:Record">Record</a> -&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="Data-Csv.html#t:Parser">Parser</a> a</li><li class="src short"><a href="#v:unsafeIndex">unsafeIndex</a> :: <a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:Record">Record</a> -&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="Data-Csv.html#t:Parser">Parser</a> a</li><li class="src short"><span class="keyword">class</span> <a href="#t:ToRecord">ToRecord</a> a <span class="keyword">where</span><ul class="subs"><li><a href="#v:toRecord">toRecord</a> :: a -&gt; <a href="Data-Csv.html#t:Record">Record</a></li></ul></li><li class="src short"><a href="#v:record">record</a> :: [ByteString] -&gt; <a href="Data-Csv.html#t:Record">Record</a></li><li class="src short"><span class="keyword">newtype</span> <a href="#t:Only">Only</a> a = <a href="#v:Only">Only</a> {<ul class="subs"><li><a href="#v:fromOnly">fromOnly</a> :: a</li></ul>}</li><li class="src short"><span class="keyword">class</span> <a href="#t:FromNamedRecord">FromNamedRecord</a> a <span class="keyword">where</span><ul class="subs"><li><a href="#v:parseNamedRecord">parseNamedRecord</a> :: <a href="Data-Csv.html#t:NamedRecord">NamedRecord</a> -&gt; <a href="Data-Csv.html#t:Parser">Parser</a> a</li></ul></li><li class="src short"><a href="#v:lookup">lookup</a> :: <a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:NamedRecord">NamedRecord</a> -&gt; ByteString -&gt; <a href="Data-Csv.html#t:Parser">Parser</a> a</li><li class="src short"><a href="#v:.:">(.:)</a> :: <a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:NamedRecord">NamedRecord</a> -&gt; ByteString -&gt; <a href="Data-Csv.html#t:Parser">Parser</a> a</li><li class="src short"><span class="keyword">class</span> <a href="#t:ToNamedRecord">ToNamedRecord</a> a <span class="keyword">where</span><ul class="subs"><li><a href="#v:toNamedRecord">toNamedRecord</a> :: a -&gt; <a href="Data-Csv.html#t:NamedRecord">NamedRecord</a></li></ul></li><li class="src short"><a href="#v:namedRecord">namedRecord</a> :: [(ByteString, ByteString)] -&gt; <a href="Data-Csv.html#t:NamedRecord">NamedRecord</a></li><li class="src short"><a href="#v:namedField">namedField</a> :: <a href="Data-Csv.html#t:ToField">ToField</a> a =&gt; ByteString -&gt; a -&gt; (ByteString, ByteString)</li><li class="src short"><a href="#v:.-61-">(.=)</a> :: <a href="Data-Csv.html#t:ToField">ToField</a> a =&gt; ByteString -&gt; a -&gt; (ByteString, ByteString)</li><li class="src short"><span class="keyword">class</span> <a href="#t:FromField">FromField</a> a <span class="keyword">where</span><ul class="subs"><li><a href="#v:parseField">parseField</a> :: <a href="Data-Csv.html#t:Field">Field</a> -&gt; <a href="Data-Csv.html#t:Parser">Parser</a> a</li></ul></li><li class="src short"><span class="keyword">class</span> <a href="#t:ToField">ToField</a> a <span class="keyword">where</span><ul class="subs"><li><a href="#v:toField">toField</a> :: a -&gt; <a href="Data-Csv.html#t:Field">Field</a></li></ul></li></ul></div><div id="interface"><h1 id="g:1">Usage example</h1><div class="doc"><p>A short encoding usage example:</p><pre>&gt;&gt;&gt; encode [(&quot;John&quot; :: Text, 27), (&quot;Jane&quot;, 28)]
&quot;John,27\r\nJane,28\r\n&quot;</pre><p>Since string literals are overloaded we have to supply a type
 signature as the compiler couldn't deduce which string type (i.e.
 <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a></code> or <code>Text</code>) we want to use. In most cases type inference
 will infer the type from the context and you can omit type
 signatures.</p><p>A short decoding usage example:</p><pre>&gt;&gt;&gt; decode NoHeader &quot;John,27\r\nJane,28\r\n&quot; :: Either String (Vector (Text, Int))
Right [(&quot;John&quot;,27),(&quot;Jane&quot;,28)]</pre><p>We pass <code><a href="Data-Csv.html#v:NoHeader">NoHeader</a></code> as the first argument to indicate that the CSV
 input data isn't preceded by a header.</p><p>In practice, the return type of <code><a href="Data-Csv.html#v:decode">decode</a></code> rarely needs to be given,
 as it can often be inferred from the context.</p></div><h1 id="g:2">Treating CSV data as opaque byte strings</h1><div class="doc"><p>Sometimes you might want to work with a CSV file which contents is
 unknown to you. For example, you might want remove the second
 column of a file without knowing anything about its content. To
 parse a CSV file to a generic representation, just convert each
 record to a <code><code>Vector</code> <code>ByteString</code></code> value, like so:</p><pre>decode NoHeader &quot;John,27\r\nJane,28\r\n&quot; :: Either String (Vector (Vector ByteString))
Right [[&quot;John&quot;,&quot;27&quot;],[&quot;Jane&quot;,&quot;28&quot;]]</pre><p>As the example output above shows, all the fields are returned as
 uninterpreted <code>ByteString</code> values.</p></div><h1 id="g:3">Custom type conversions</h1><div class="doc"><p>Most of the time the existing <code><a href="Data-Csv.html#t:FromField">FromField</a></code> and <code><a href="Data-Csv.html#t:ToField">ToField</a></code> instances
 do what you want. However, if you need to parse a different format
 (e.g. hex) but use a type (e.g. <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></code>) for which there's already a
 <code><a href="Data-Csv.html#t:FromField">FromField</a></code> instance, you need to use a <code>newtype</code>. Example:</p><pre>newtype Hex = Hex Int

parseHex :: ByteString -&gt; Parser Int
parseHex = ...

instance FromField Hex where
    parseField s = Hex &lt;$&gt; parseHex s</pre><p>Other than giving an explicit type signature, you can pattern match
 on the <code>newtype</code> constructor to indicate which type conversion you
 want to have the library use:</p><pre>case decode NoHeader &quot;0xff,0xaa\r\n0x11,0x22\r\n&quot; of
    Left err -&gt; putStrLn err
    Right v  -&gt; forM_ v $ \ (Hex val1, Hex val2) -&gt;
        print (val1, val2)</pre><p>If a field might be in one several different formats, you can use a
 newtype to normalize the result:</p><pre>newtype HexOrDecimal = HexOrDecimal Int

instance FromField DefaultToZero where
    parseField s = case runParser (parseField s :: Parser Hex) of
        Left err -&gt; HexOrDecimal &lt;$&gt; parseField s  -- Uses Int instance
        Right n  -&gt; pure $ HexOrDecimal n</pre><p>You can use the unit type, <code>()</code>, to ignore a column. The
 <code><a href="Data-Csv.html#v:parseField">parseField</a></code> method for <code>()</code> doesn't look at the <code><a href="Data-Csv.html#t:Field">Field</a></code> and thus
 always decodes successfully. Note that it lacks a corresponding
 <code><a href="Data-Csv.html#t:ToField">ToField</a></code> instance. Example:</p><pre>case decode NoHeader &quot;foo,1\r\nbar,22&quot; of
    Left  err -&gt; putStrLn err
    Right v   -&gt; forM_ v $ \ ((), i) -&gt; print (i :: Int)</pre></div><h2 id="g:4">Dealing with bad data</h2><div class="doc"><p>If your input might contain invalid fields, you can write a custom
 <code><a href="Data-Csv.html#t:FromField">FromField</a></code> instance to deal with them. Example:</p><pre>newtype DefaultToZero = DefaultToZero Int

instance FromField DefaultToZero where
    parseField s = case runParser (parseField s) of
        Left err -&gt; pure $ DefaultToZero 0
        Right n  -&gt; pure $ DefaultToZero n</pre></div><h1 id="g:5">Encoding and decoding</h1><div class="doc"><p>Encoding and decoding is a two step process. To encode a value, it
 is first converted to a generic representation, using either
 <code><a href="Data-Csv.html#t:ToRecord">ToRecord</a></code> or <code><a href="Data-Csv.html#t:ToNamedRecord">ToNamedRecord</a></code>. The generic representation is then
 encoded as CSV data. To decode a value the process is reversed and
 either <code><a href="Data-Csv.html#t:FromRecord">FromRecord</a></code> or <code><a href="Data-Csv.html#t:FromNamedRecord">FromNamedRecord</a></code> is used instead. Both
 these steps are combined in the <code><a href="Data-Csv.html#v:encode">encode</a></code> and <code><a href="Data-Csv.html#v:decode">decode</a></code> functions.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:HasHeader" class="def">HasHeader</a></p><div class="doc"><p>Is the CSV data preceded by a header?</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:HasHeader" class="def">HasHeader</a></td><td class="doc"><p>The CSV data is preceded by a header</p></td></tr><tr><td class="src"><a name="v:NoHeader" class="def">NoHeader</a></td><td class="doc"><p>The CSV data is not preceded by a header</p></td></tr></table></div></div><div class="top"><p class="src"><a name="v:decode" class="def">decode</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Data-Csv.html#t:FromRecord">FromRecord</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Data-Csv.html#t:HasHeader">HasHeader</a></td><td class="doc"><p>Data contains header that should be
 skipped</p></td></tr><tr><td class="src">-&gt; ByteString</td><td class="doc"><p>CSV data</p></td></tr><tr><td class="src">-&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (Vector a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Efficiently deserialize CSV records from a lazy <code>ByteString</code>.
 If this fails due to incomplete or invalid input, <code><code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Left">Left</a></code> msg</code> is
 returned. Equivalent to <code><code><a href="Data-Csv.html#v:decodeWith">decodeWith</a></code> <code><a href="Data-Csv.html#v:defaultDecodeOptions">defaultDecodeOptions</a></code></code>.</p></div></div><div class="top"><p class="src"><a name="v:decodeByName" class="def">decodeByName</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Data-Csv.html#t:FromNamedRecord">FromNamedRecord</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; ByteString</td><td class="doc"><p>CSV data</p></td></tr><tr><td class="src">-&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (<a href="Data-Csv.html#t:Header">Header</a>, Vector a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Efficiently deserialize CSV records from a lazy <code>ByteString</code>.
 If this fails due to incomplete or invalid input, <code><code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Left">Left</a></code> msg</code> is
 returned. The data is assumed to be preceeded by a header.
 Equivalent to <code><code><a href="Data-Csv.html#v:decodeByNameWith">decodeByNameWith</a></code> <code><a href="Data-Csv.html#v:defaultDecodeOptions">defaultDecodeOptions</a></code></code>.</p></div></div><div class="top"><p class="src"><a name="v:encode" class="def">encode</a> :: <a href="Data-Csv.html#t:ToRecord">ToRecord</a> a =&gt; [a] -&gt; ByteString</p><div class="doc"><p>Efficiently serialize CSV records as a lazy <code>ByteString</code>.</p></div></div><div class="top"><p class="src"><a name="v:encodeByName" class="def">encodeByName</a> :: <a href="Data-Csv.html#t:ToNamedRecord">ToNamedRecord</a> a =&gt; <a href="Data-Csv.html#t:Header">Header</a> -&gt; [a] -&gt; ByteString</p><div class="doc"><p>Efficiently serialize CSV records as a lazy <code>ByteString</code>. The
 header is written before any records and dictates the field order.</p></div></div><h2 id="g:6">Encoding and decoding options</h2><div class="doc"><p>These functions can be used to control how data is encoded and
 decoded. For example, they can be used to encode data in a
 tab-separated format instead of in a comma-separated format.</p></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:DecodeOptions" class="def">DecodeOptions</a></p><div class="doc"><p>Options that controls how data is decoded. These options can be
 used to e.g. decode tab-separated data instead of comma-separated
 data.</p><p>To avoid having your program stop compiling when new fields are
 added to <code><a href="Data-Csv.html#t:DecodeOptions">DecodeOptions</a></code>, create option records by overriding
 values in <code><a href="Data-Csv.html#v:defaultDecodeOptions">defaultDecodeOptions</a></code>. Example:</p><pre>myOptions = defaultDecodeOptions {
      decDelimiter = fromIntegral (ord '\t')
    }</pre></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:DecodeOptions" class="def">DecodeOptions</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:decDelimiter" class="def">decDelimiter</a> :: !<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Word.html#t:Word8">Word8</a></dt><dd class="doc"><p>Field delimiter.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:DecodeOptions" class="caption collapser" onclick="toggleSection('i:DecodeOptions')">Instances</p><div id="section.i:DecodeOptions" class="show"><table><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Eq.html#t:Eq">Eq</a> <a href="Data-Csv.html#t:DecodeOptions">DecodeOptions</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> <a href="Data-Csv.html#t:DecodeOptions">DecodeOptions</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:defaultDecodeOptions" class="def">defaultDecodeOptions</a> :: <a href="Data-Csv.html#t:DecodeOptions">DecodeOptions</a></p><div class="doc"><p>Decoding options for parsing CSV files.</p></div></div><div class="top"><p class="src"><a name="v:decodeWith" class="def">decodeWith</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Data-Csv.html#t:FromRecord">FromRecord</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Data-Csv.html#t:DecodeOptions">DecodeOptions</a></td><td class="doc"><p>Decoding options</p></td></tr><tr><td class="src">-&gt; <a href="Data-Csv.html#t:HasHeader">HasHeader</a></td><td class="doc"><p>Data contains header that should be
 skipped</p></td></tr><tr><td class="src">-&gt; ByteString</td><td class="doc"><p>CSV data</p></td></tr><tr><td class="src">-&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (Vector a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="Data-Csv.html#v:decode">decode</a></code>, but lets you customize how the CSV data is parsed.</p></div></div><div class="top"><p class="src"><a name="v:decodeByNameWith" class="def">decodeByNameWith</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Data-Csv.html#t:FromNamedRecord">FromNamedRecord</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">=&gt; <a href="Data-Csv.html#t:DecodeOptions">DecodeOptions</a></td><td class="doc"><p>Decoding options</p></td></tr><tr><td class="src">-&gt; ByteString</td><td class="doc"><p>CSV data</p></td></tr><tr><td class="src">-&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> (<a href="Data-Csv.html#t:Header">Header</a>, Vector a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Like <code><a href="Data-Csv.html#v:decodeByName">decodeByName</a></code>, but lets you customize how the CSV data is
 parsed.</p></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:EncodeOptions" class="def">EncodeOptions</a></p><div class="doc"><p>Options that controls how data is encoded. These options can be
 used to e.g. encode data in a tab-separated format instead of in a
 comma-separated format.</p><p>To avoid having your program stop compiling when new fields are
 added to <code><a href="Data-Csv.html#t:EncodeOptions">EncodeOptions</a></code>, create option records by overriding
 values in <code><a href="Data-Csv.html#v:defaultEncodeOptions">defaultEncodeOptions</a></code>. Example:</p><pre>myOptions = defaultEncodeOptions {
      encDelimiter = fromIntegral (ord '\t')
    }</pre><p><em>N.B.</em> The <code><a href="Data-Csv.html#v:encDelimiter">encDelimiter</a></code> must <em>not</em> be the quote character (i.e.
 <code>&quot;</code>) or one of the record separator characters (i.e. <code>\n</code> or
 <code>\r</code>).</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:EncodeOptions" class="def">EncodeOptions</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:encDelimiter" class="def">encDelimiter</a> :: !<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Word.html#t:Word8">Word8</a></dt><dd class="doc"><p>Field delimiter.</p></dd><dt class="src"><a name="v:encUseCrLf" class="def">encUseCrLf</a> :: !<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Bool.html#t:Bool">Bool</a></dt><dd class="doc"><p>Record separator selection.  <code>True</code> for CRLF (<code>\r\n</code>) and
 <code>False</code> for LF (<code>\n</code>).</p></dd><dt class="src"><a name="v:encIncludeHeader" class="def">encIncludeHeader</a> :: !<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Bool.html#t:Bool">Bool</a></dt><dd class="doc"><p>Include a header row when encoding <code>ToNamedRecord</code>
 instances.</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:EncodeOptions" class="caption collapser" onclick="toggleSection('i:EncodeOptions')">Instances</p><div id="section.i:EncodeOptions" class="show"><table><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Eq.html#t:Eq">Eq</a> <a href="Data-Csv.html#t:EncodeOptions">EncodeOptions</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> <a href="Data-Csv.html#t:EncodeOptions">EncodeOptions</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:defaultEncodeOptions" class="def">defaultEncodeOptions</a> :: <a href="Data-Csv.html#t:EncodeOptions">EncodeOptions</a></p><div class="doc"><p>Encoding options for CSV files.</p></div></div><div class="top"><p class="src"><a name="v:encodeWith" class="def">encodeWith</a> :: <a href="Data-Csv.html#t:ToRecord">ToRecord</a> a =&gt; <a href="Data-Csv.html#t:EncodeOptions">EncodeOptions</a> -&gt; [a] -&gt; ByteString</p><div class="doc"><p>Like <code><a href="Data-Csv.html#v:encode">encode</a></code>, but lets you customize how the CSV data is
 encoded.</p></div></div><div class="top"><p class="src"><a name="v:encodeByNameWith" class="def">encodeByNameWith</a> :: <a href="Data-Csv.html#t:ToNamedRecord">ToNamedRecord</a> a =&gt; <a href="Data-Csv.html#t:EncodeOptions">EncodeOptions</a> -&gt; <a href="Data-Csv.html#t:Header">Header</a> -&gt; [a] -&gt; ByteString</p><div class="doc"><p>Like <code><a href="Data-Csv.html#v:encodeByName">encodeByName</a></code>, but lets you customize how the CSV data is
 encoded.</p></div></div><h1 id="g:7">Core CSV types</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Csv" class="def">Csv</a> = Vector <a href="Data-Csv.html#t:Record">Record</a></p><div class="doc"><p>CSV data represented as a Haskell vector of vector of
 bytestrings.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Record" class="def">Record</a> = Vector <a href="Data-Csv.html#t:Field">Field</a></p><div class="doc"><p>A record corresponds to a single line in a CSV file.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Field" class="def">Field</a> = ByteString</p><div class="doc"><p>A single field within a record.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Header" class="def">Header</a> = Vector <a href="Data-Csv.html#t:Name">Name</a></p><div class="doc"><p>The header corresponds to the first line a CSV file. Not all CSV
 files have a header.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Name" class="def">Name</a> = ByteString</p><div class="doc"><p>A header has one or more names, describing the data in the column
 following the name.</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:NamedRecord" class="def">NamedRecord</a> = <a href="file:///Users/horus/projects/haskell/csv/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/unordered-containers-0.2.5.1/html/Data-HashMap-Strict.html#t:HashMap">HashMap</a> ByteString ByteString</p><div class="doc"><p>A record corresponds to a single line in a CSV file, indexed by
 the column name rather than the column index.</p></div></div><h1 id="g:8">Type conversion</h1><div class="doc"><p>There are two ways to convert CSV records to and from and
 user-defined data types: index-based conversion and name-based
 conversion.</p></div><h2 id="g:9">Index-based record conversion</h2><div class="doc"><p>Index-based conversion lets you convert CSV records to and from
 user-defined data types by referring to a field's position (its
 index) in the record. The first column in a CSV file is given index
 0, the second index 1, and so on.</p></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:FromRecord" class="def">FromRecord</a> a <span class="keyword">where</span></p><div class="doc"><p>A type that can be converted from a single CSV record, with the
 possibility of failure.</p><p>When writing an instance, use <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:empty">empty</a></code>, <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#v:mzero">mzero</a></code>, or <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#v:fail">fail</a></code> to make a
 conversion fail, e.g. if a <code><a href="Data-Csv.html#t:Record">Record</a></code> has the wrong number of
 columns.</p><p>Given this example data:</p><pre>John,56
Jane,55</pre><p>here's an example type and instance:</p><pre>data Person = Person { name :: !Text, age :: !Int }

instance FromRecord Person where
    parseRecord v
        | length v == 2 = Person &lt;$&gt;
                          v .! 0 &lt;*&gt;
                          v .! 1
        | otherwise     = mzero</pre></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src">Nothing</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:parseRecord" class="def">parseRecord</a> :: <a href="Data-Csv.html#t:Record">Record</a> -&gt; <a href="Data-Csv.html#t:Parser">Parser</a> a</p></div><div class="subs instances"><p id="control.i:FromRecord" class="caption collapser" onclick="toggleSection('i:FromRecord')">Instances</p><div id="section.i:FromRecord" class="show"><table><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:FromRecord">FromRecord</a> [a]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:FromRecord">FromRecord</a> (Vector a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:FromField">FromField</a> a, Unbox a) =&gt; <a href="Data-Csv.html#t:FromRecord">FromRecord</a> (Vector a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:FromRecord">FromRecord</a> (<a href="Data-Csv.html#t:Only">Only</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:FromField">FromField</a> a, <a href="Data-Csv.html#t:FromField">FromField</a> b) =&gt; <a href="Data-Csv.html#t:FromRecord">FromRecord</a> (a, b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:FromField">FromField</a> a, <a href="Data-Csv.html#t:FromField">FromField</a> b, <a href="Data-Csv.html#t:FromField">FromField</a> c) =&gt; <a href="Data-Csv.html#t:FromRecord">FromRecord</a> (a, b, c)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:FromField">FromField</a> a, <a href="Data-Csv.html#t:FromField">FromField</a> b, <a href="Data-Csv.html#t:FromField">FromField</a> c, <a href="Data-Csv.html#t:FromField">FromField</a> d) =&gt; <a href="Data-Csv.html#t:FromRecord">FromRecord</a> (a, b, c, d)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:FromField">FromField</a> a, <a href="Data-Csv.html#t:FromField">FromField</a> b, <a href="Data-Csv.html#t:FromField">FromField</a> c, <a href="Data-Csv.html#t:FromField">FromField</a> d, <a href="Data-Csv.html#t:FromField">FromField</a> e) =&gt; <a href="Data-Csv.html#t:FromRecord">FromRecord</a> (a, b, c, d, e)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:FromField">FromField</a> a, <a href="Data-Csv.html#t:FromField">FromField</a> b, <a href="Data-Csv.html#t:FromField">FromField</a> c, <a href="Data-Csv.html#t:FromField">FromField</a> d, <a href="Data-Csv.html#t:FromField">FromField</a> e, <a href="Data-Csv.html#t:FromField">FromField</a> f) =&gt; <a href="Data-Csv.html#t:FromRecord">FromRecord</a> (a, b, c, d, e, f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:FromField">FromField</a> a, <a href="Data-Csv.html#t:FromField">FromField</a> b, <a href="Data-Csv.html#t:FromField">FromField</a> c, <a href="Data-Csv.html#t:FromField">FromField</a> d, <a href="Data-Csv.html#t:FromField">FromField</a> e, <a href="Data-Csv.html#t:FromField">FromField</a> f, <a href="Data-Csv.html#t:FromField">FromField</a> g) =&gt; <a href="Data-Csv.html#t:FromRecord">FromRecord</a> (a, b, c, d, e, f, g)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:FromField">FromField</a> a, <a href="Data-Csv.html#t:FromField">FromField</a> b, <a href="Data-Csv.html#t:FromField">FromField</a> c, <a href="Data-Csv.html#t:FromField">FromField</a> d, <a href="Data-Csv.html#t:FromField">FromField</a> e, <a href="Data-Csv.html#t:FromField">FromField</a> f, <a href="Data-Csv.html#t:FromField">FromField</a> g, <a href="Data-Csv.html#t:FromField">FromField</a> h) =&gt; <a href="Data-Csv.html#t:FromRecord">FromRecord</a> (a, b, c, d, e, f, g, h)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:FromField">FromField</a> a, <a href="Data-Csv.html#t:FromField">FromField</a> b, <a href="Data-Csv.html#t:FromField">FromField</a> c, <a href="Data-Csv.html#t:FromField">FromField</a> d, <a href="Data-Csv.html#t:FromField">FromField</a> e, <a href="Data-Csv.html#t:FromField">FromField</a> f, <a href="Data-Csv.html#t:FromField">FromField</a> g, <a href="Data-Csv.html#t:FromField">FromField</a> h, <a href="Data-Csv.html#t:FromField">FromField</a> i) =&gt; <a href="Data-Csv.html#t:FromRecord">FromRecord</a> (a, b, c, d, e, f, g, h, i)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span> <a name="t:Parser" class="def">Parser</a> a</p><div class="doc"><p>Conversion of a field to a value might fail e.g. if the field is
 malformed. This possibility is captured by the <code><a href="Data-Csv.html#t:Parser">Parser</a></code> type, which
 lets you compose several field conversions together in such a way
 that if any of them fail, the whole record conversion fails.</p></div><div class="subs instances"><p id="control.i:Parser" class="caption collapser" onclick="toggleSection('i:Parser')">Instances</p><div id="section.i:Parser" class="show"><table><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Alternative">Alternative</a> <a href="Data-Csv.html#t:Parser">Parser</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Monad">Monad</a> <a href="Data-Csv.html#t:Parser">Parser</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:Functor">Functor</a> <a href="Data-Csv.html#t:Parser">Parser</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#t:MonadPlus">MonadPlus</a> <a href="Data-Csv.html#t:Parser">Parser</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#t:Applicative">Applicative</a> <a href="Data-Csv.html#t:Parser">Parser</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Monoid.html#t:Monoid">Monoid</a> (<a href="Data-Csv.html#t:Parser">Parser</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:runParser" class="def">runParser</a> ::  <a href="Data-Csv.html#t:Parser">Parser</a> a -&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-String.html#t:String">String</a> a</p><div class="doc"><p>Run a <code><a href="Data-Csv.html#t:Parser">Parser</a></code>, returning either <code><code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Left">Left</a></code> errMsg</code> or <code><code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Right">Right</a></code>
 result</code>. Forces the value in the <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Left">Left</a></code> or <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Right">Right</a></code> constructors to
 weak head normal form.</p><p>You most likely won't need to use this function directly, but it's
 included for completeness.</p></div></div><div class="top"><p class="src"><a name="v:index" class="def">index</a> :: <a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:Record">Record</a> -&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="Data-Csv.html#t:Parser">Parser</a> a</p><div class="doc"><p>Retrieve the <em>n</em>th field in the given record. The result is
 <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:empty">empty</a></code> if the value cannot be converted to the desired type.
 Raises an exception if the index is out of bounds.</p><p><code><a href="Data-Csv.html#v:index">index</a></code> is a simple convenience function that is equivalent to
 <code><code><a href="Data-Csv.html#v:parseField">parseField</a></code> (v <code>!</code> idx)</code>. If you're certain that the index is not
 out of bounds, using <code><a href="Data-Csv.html#v:unsafeIndex">unsafeIndex</a></code> is somewhat faster.</p></div></div><div class="top"><p class="src"><a name="v:.-33-" class="def">(.!)</a> :: <a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:Record">Record</a> -&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="Data-Csv.html#t:Parser">Parser</a> a <span class="fixity">infixl 9</span><span class="rightedge"></span></p><div class="doc"><p>Alias for <code><a href="Data-Csv.html#v:index">index</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:unsafeIndex" class="def">unsafeIndex</a> :: <a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:Record">Record</a> -&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a> -&gt; <a href="Data-Csv.html#t:Parser">Parser</a> a</p><div class="doc"><p>Like <code><a href="Data-Csv.html#v:index">index</a></code> but without bounds checking.</p></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:ToRecord" class="def">ToRecord</a> a <span class="keyword">where</span></p><div class="doc"><p>A type that can be converted to a single CSV record.</p><p>An example type and instance:</p><pre>data Person = Person { name :: !Text, age :: !Int }

instance ToRecord Person where
    toRecord (Person name age) = record [
        toField name, toField age]</pre><p>Outputs data on this form:</p><pre>John,56
Jane,55</pre></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src">Nothing</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:toRecord" class="def">toRecord</a> :: a -&gt; <a href="Data-Csv.html#t:Record">Record</a></p></div><div class="subs instances"><p id="control.i:ToRecord" class="caption collapser" onclick="toggleSection('i:ToRecord')">Instances</p><div id="section.i:ToRecord" class="show"><table><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> a =&gt; <a href="Data-Csv.html#t:ToRecord">ToRecord</a> [a]</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> a =&gt; <a href="Data-Csv.html#t:ToRecord">ToRecord</a> (Vector a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:ToField">ToField</a> a, Unbox a) =&gt; <a href="Data-Csv.html#t:ToRecord">ToRecord</a> (Vector a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> a =&gt; <a href="Data-Csv.html#t:ToRecord">ToRecord</a> (<a href="Data-Csv.html#t:Only">Only</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:ToField">ToField</a> a, <a href="Data-Csv.html#t:ToField">ToField</a> b) =&gt; <a href="Data-Csv.html#t:ToRecord">ToRecord</a> (a, b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:ToField">ToField</a> a, <a href="Data-Csv.html#t:ToField">ToField</a> b, <a href="Data-Csv.html#t:ToField">ToField</a> c) =&gt; <a href="Data-Csv.html#t:ToRecord">ToRecord</a> (a, b, c)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:ToField">ToField</a> a, <a href="Data-Csv.html#t:ToField">ToField</a> b, <a href="Data-Csv.html#t:ToField">ToField</a> c, <a href="Data-Csv.html#t:ToField">ToField</a> d) =&gt; <a href="Data-Csv.html#t:ToRecord">ToRecord</a> (a, b, c, d)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:ToField">ToField</a> a, <a href="Data-Csv.html#t:ToField">ToField</a> b, <a href="Data-Csv.html#t:ToField">ToField</a> c, <a href="Data-Csv.html#t:ToField">ToField</a> d, <a href="Data-Csv.html#t:ToField">ToField</a> e) =&gt; <a href="Data-Csv.html#t:ToRecord">ToRecord</a> (a, b, c, d, e)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:ToField">ToField</a> a, <a href="Data-Csv.html#t:ToField">ToField</a> b, <a href="Data-Csv.html#t:ToField">ToField</a> c, <a href="Data-Csv.html#t:ToField">ToField</a> d, <a href="Data-Csv.html#t:ToField">ToField</a> e, <a href="Data-Csv.html#t:ToField">ToField</a> f) =&gt; <a href="Data-Csv.html#t:ToRecord">ToRecord</a> (a, b, c, d, e, f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:ToField">ToField</a> a, <a href="Data-Csv.html#t:ToField">ToField</a> b, <a href="Data-Csv.html#t:ToField">ToField</a> c, <a href="Data-Csv.html#t:ToField">ToField</a> d, <a href="Data-Csv.html#t:ToField">ToField</a> e, <a href="Data-Csv.html#t:ToField">ToField</a> f, <a href="Data-Csv.html#t:ToField">ToField</a> g) =&gt; <a href="Data-Csv.html#t:ToRecord">ToRecord</a> (a, b, c, d, e, f, g)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:ToField">ToField</a> a, <a href="Data-Csv.html#t:ToField">ToField</a> b, <a href="Data-Csv.html#t:ToField">ToField</a> c, <a href="Data-Csv.html#t:ToField">ToField</a> d, <a href="Data-Csv.html#t:ToField">ToField</a> e, <a href="Data-Csv.html#t:ToField">ToField</a> f, <a href="Data-Csv.html#t:ToField">ToField</a> g, <a href="Data-Csv.html#t:ToField">ToField</a> h) =&gt; <a href="Data-Csv.html#t:ToRecord">ToRecord</a> (a, b, c, d, e, f, g, h)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Data-Csv.html#t:ToField">ToField</a> a, <a href="Data-Csv.html#t:ToField">ToField</a> b, <a href="Data-Csv.html#t:ToField">ToField</a> c, <a href="Data-Csv.html#t:ToField">ToField</a> d, <a href="Data-Csv.html#t:ToField">ToField</a> e, <a href="Data-Csv.html#t:ToField">ToField</a> f, <a href="Data-Csv.html#t:ToField">ToField</a> g, <a href="Data-Csv.html#t:ToField">ToField</a> h, <a href="Data-Csv.html#t:ToField">ToField</a> i) =&gt; <a href="Data-Csv.html#t:ToRecord">ToRecord</a> (a, b, c, d, e, f, g, h, i)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:record" class="def">record</a> :: [ByteString] -&gt; <a href="Data-Csv.html#t:Record">Record</a></p><div class="doc"><p>Construct a record from a list of <code>ByteString</code>s.  Use <code><a href="Data-Csv.html#v:toField">toField</a></code>
 to convert values to <code>ByteString</code>s for use with <code><a href="Data-Csv.html#v:record">record</a></code>.</p></div></div><div class="top"><p class="src"><span class="keyword">newtype</span> <a name="t:Only" class="def">Only</a> a</p><div class="doc"><p>Haskell lacks a single-element tuple type, so if you CSV data
 with just one column you can use the <code><a href="Data-Csv.html#t:Only">Only</a></code> type to represent a
 single-column result.</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Only" class="def">Only</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:fromOnly" class="def">fromOnly</a> :: a</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:Only" class="caption collapser" onclick="toggleSection('i:Only')">Instances</p><div id="section.i:Only" class="show"><table><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Eq.html#t:Eq">Eq</a> a =&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Eq.html#t:Eq">Eq</a> (<a href="Data-Csv.html#t:Only">Only</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> a =&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Ord.html#t:Ord">Ord</a> (<a href="Data-Csv.html#t:Only">Only</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Read.html#t:Read">Read</a> a =&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Read.html#t:Read">Read</a> (<a href="Data-Csv.html#t:Only">Only</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> a =&gt; <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Text-Show.html#t:Show">Show</a> (<a href="Data-Csv.html#t:Only">Only</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> a =&gt; <a href="Data-Csv.html#t:ToRecord">ToRecord</a> (<a href="Data-Csv.html#t:Only">Only</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:FromRecord">FromRecord</a> (<a href="Data-Csv.html#t:Only">Only</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:10">Name-based record conversion</h2><div class="doc"><p>Name-based conversion lets you convert CSV records to and from
 user-defined data types by referring to a field's name. The names
 of the fields are defined by the first line in the file, also known
 as the header. Name-based conversion is more robust to changes in
 the file structure e.g. to reording or addition of columns, but can
 be a bit slower.</p></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:FromNamedRecord" class="def">FromNamedRecord</a> a <span class="keyword">where</span></p><div class="doc"><p>A type that can be converted from a single CSV record, with the
 possibility of failure.</p><p>When writing an instance, use <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:empty">empty</a></code>, <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#v:mzero">mzero</a></code>, or <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#v:fail">fail</a></code> to make a
 conversion fail, e.g. if a <code><a href="Data-Csv.html#t:Record">Record</a></code> has the wrong number of
 columns.</p><p>Given this example data:</p><pre>name,age
John,56
Jane,55</pre><p>here's an example type and instance:</p><pre>{-# LANGUAGE OverloadedStrings #-}

data Person = Person { name :: !Text, age :: !Int }

instance FromNamedRecord Person where
    parseNamedRecord m = Person &lt;$&gt;
                         m .: &quot;name&quot; &lt;*&gt;
                         m .: &quot;age&quot;</pre><p>Note the use of the <code>OverloadedStrings</code> language extension which
 enables <code>ByteString</code> values to be written as string literals.</p></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src">Nothing</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:parseNamedRecord" class="def">parseNamedRecord</a> :: <a href="Data-Csv.html#t:NamedRecord">NamedRecord</a> -&gt; <a href="Data-Csv.html#t:Parser">Parser</a> a</p></div><div class="subs instances"><p id="control.i:FromNamedRecord" class="caption collapser" onclick="toggleSection('i:FromNamedRecord')">Instances</p><div id="section.i:FromNamedRecord" class="show"><table><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:FromNamedRecord">FromNamedRecord</a> (<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/containers-0.5.5.1/Data-Map-Lazy.html#t:Map">Map</a> ByteString a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:FromNamedRecord">FromNamedRecord</a> (<a href="file:///Users/horus/projects/haskell/csv/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/unordered-containers-0.2.5.1/html/Data-HashMap-Strict.html#t:HashMap">HashMap</a> ByteString a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:lookup" class="def">lookup</a> :: <a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:NamedRecord">NamedRecord</a> -&gt; ByteString -&gt; <a href="Data-Csv.html#t:Parser">Parser</a> a</p><div class="doc"><p>Retrieve a field in the given record by name.  The result is
 <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:empty">empty</a></code> if the field is missing or if the value cannot be converted
 to the desired type.</p></div></div><div class="top"><p class="src"><a name="v:.:" class="def">(.:)</a> :: <a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:NamedRecord">NamedRecord</a> -&gt; ByteString -&gt; <a href="Data-Csv.html#t:Parser">Parser</a> a</p><div class="doc"><p>Alias for <code><a href="Data-Csv.html#v:lookup">lookup</a></code>.</p></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:ToNamedRecord" class="def">ToNamedRecord</a> a <span class="keyword">where</span></p><div class="doc"><p>A type that can be converted to a single CSV record.</p><p>An example type and instance:</p><pre>data Person = Person { name :: !Text, age :: !Int }

instance ToNamedRecord Person where
    toNamedRecord (Person name age) = namedRecord [
        &quot;name&quot; .= name, &quot;age&quot; .= age]</pre></div><div class="subs minimal"><p class="caption">Minimal complete definition</p><p class="src">Nothing</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:toNamedRecord" class="def">toNamedRecord</a> :: a -&gt; <a href="Data-Csv.html#t:NamedRecord">NamedRecord</a></p></div><div class="subs instances"><p id="control.i:ToNamedRecord" class="caption collapser" onclick="toggleSection('i:ToNamedRecord')">Instances</p><div id="section.i:ToNamedRecord" class="show"><table><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> a =&gt; <a href="Data-Csv.html#t:ToNamedRecord">ToNamedRecord</a> (<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/containers-0.5.5.1/Data-Map-Lazy.html#t:Map">Map</a> ByteString a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> a =&gt; <a href="Data-Csv.html#t:ToNamedRecord">ToNamedRecord</a> (<a href="file:///Users/horus/projects/haskell/csv/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/unordered-containers-0.2.5.1/html/Data-HashMap-Strict.html#t:HashMap">HashMap</a> ByteString a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:namedRecord" class="def">namedRecord</a> :: [(ByteString, ByteString)] -&gt; <a href="Data-Csv.html#t:NamedRecord">NamedRecord</a></p><div class="doc"><p>Construct a named record from a list of name-value <code>ByteString</code>
 pairs.  Use <code><a href="Data-Csv.html#v:.-61-">.=</a></code> to construct such a pair from a name and a value.</p></div></div><div class="top"><p class="src"><a name="v:namedField" class="def">namedField</a> :: <a href="Data-Csv.html#t:ToField">ToField</a> a =&gt; ByteString -&gt; a -&gt; (ByteString, ByteString)</p><div class="doc"><p>Construct a pair from a name and a value.  For use with
 <code><a href="Data-Csv.html#v:namedRecord">namedRecord</a></code>.</p></div></div><div class="top"><p class="src"><a name="v:.-61-" class="def">(.=)</a> :: <a href="Data-Csv.html#t:ToField">ToField</a> a =&gt; ByteString -&gt; a -&gt; (ByteString, ByteString)</p><div class="doc"><p>Alias for <code><a href="Data-Csv.html#v:namedField">namedField</a></code>.</p></div></div><h2 id="g:11">Field conversion</h2><div class="doc"><p>The <code><a href="Data-Csv.html#t:FromField">FromField</a></code> and <code><a href="Data-Csv.html#t:ToField">ToField</a></code> classes define how to convert between
 <code><a href="Data-Csv.html#t:Field">Field</a></code>s and values you care about (e.g. <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></code>s). Most of the time
 you don't need to write your own instances as the standard ones
 cover most use cases.</p></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:FromField" class="def">FromField</a> a <span class="keyword">where</span></p><div class="doc"><p>A type that can be converted from a single CSV field, with the
 possibility of failure.</p><p>When writing an instance, use <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Applicative.html#v:empty">empty</a></code>, <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#v:mzero">mzero</a></code>, or <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Control-Monad.html#v:fail">fail</a></code> to make a
 conversion fail, e.g. if a <code><a href="Data-Csv.html#t:Field">Field</a></code> can't be converted to the given
 type.</p><p>Example type and instance:</p><pre>{-# LANGUAGE OverloadedStrings #-}

data Color = Red | Green | Blue

instance FromField Color where
    parseField s
        | s == &quot;R&quot;  = pure Red
        | s == &quot;G&quot;  = pure Green
        | s == &quot;B&quot;  = pure Blue
        | otherwise = mzero</pre></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:parseField" class="def">parseField</a> :: <a href="Data-Csv.html#t:Field">Field</a> -&gt; <a href="Data-Csv.html#t:Parser">Parser</a> a</p></div><div class="subs instances"><p id="control.i:FromField" class="caption collapser" onclick="toggleSection('i:FromField')">Instances</p><div id="section.i:FromField" class="show"><table><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Char.html#t:Char">Char</a></td><td class="doc"><p>Assumes UTF-8 encoding.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Double">Double</a></td><td class="doc"><p>Accepts same syntax as <code>rational</code>. Ignores whitespace.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Float">Float</a></td><td class="doc"><p>Accepts same syntax as <code>rational</code>. Ignores whitespace.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>Accepts a signed decimal number. Ignores whitespace.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int8">Int8</a></td><td class="doc"><p>Accepts a signed decimal number. Ignores whitespace.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int16">Int16</a></td><td class="doc"><p>Accepts a signed decimal number. Ignores whitespace.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int32">Int32</a></td><td class="doc"><p>Accepts a signed decimal number. Ignores whitespace.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int64">Int64</a></td><td class="doc"><p>Accepts a signed decimal number. Ignores whitespace.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Integer">Integer</a></td><td class="doc"><p>Accepts a signed decimal number. Ignores whitespace.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Word.html#t:Word">Word</a></td><td class="doc"><p>Accepts an unsigned decimal number. Ignores whitespace.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Word.html#t:Word8">Word8</a></td><td class="doc"><p>Accepts an unsigned decimal number. Ignores whitespace.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Word.html#t:Word16">Word16</a></td><td class="doc"><p>Accepts an unsigned decimal number. Ignores whitespace.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Word.html#t:Word32">Word32</a></td><td class="doc"><p>Accepts an unsigned decimal number. Ignores whitespace.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Word.html#t:Word64">Word64</a></td><td class="doc"><p>Accepts an unsigned decimal number. Ignores whitespace.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> ()</td><td class="doc"><p>Ignores the <code><a href="Data-Csv.html#t:Field">Field</a></code>. Always succeeds.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> ByteString</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> ByteString</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> <a href="file:///Users/horus/projects/haskell/csv/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/text-1.2.0.5/html/Data-Text-Lazy.html#t:Text">Text</a></td><td class="doc"><p>Assumes UTF-8 encoding. Fails on invalid byte sequences.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> <a href="file:///Users/horus/projects/haskell/csv/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/text-1.2.0.5/html/Data-Text.html#t:Text">Text</a></td><td class="doc"><p>Assumes UTF-8 encoding. Fails on invalid byte sequences.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> [<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Char.html#t:Char">Char</a>]</td><td class="doc"><p>Assumes UTF-8 encoding. Fails on invalid byte sequences.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:FromField">FromField</a> (<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a> a)</td><td class="doc"><p><code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#v:Nothing">Nothing</a></code> if the <code><a href="Data-Csv.html#t:Field">Field</a></code> is <code>empty</code>, <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#v:Just">Just</a></code> otherwise.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:FromField">FromField</a> a =&gt; <a href="Data-Csv.html#t:FromField">FromField</a> (<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#t:Either">Either</a> <a href="Data-Csv.html#t:Field">Field</a> a)</td><td class="doc"><p><code><code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Left">Left</a></code> field</code> if conversion failed, <code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Either.html#v:Right">Right</a></code> otherwise.</p></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> <a name="t:ToField" class="def">ToField</a> a <span class="keyword">where</span></p><div class="doc"><p>A type that can be converted to a single CSV field.</p><p>Example type and instance:</p><pre>{-# LANGUAGE OverloadedStrings #-}

data Color = Red | Green | Blue

instance ToField Color where
    toField Red   = &quot;R&quot;
    toField Green = &quot;G&quot;
    toField Blue  = &quot;B&quot;</pre></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:toField" class="def">toField</a> :: a -&gt; <a href="Data-Csv.html#t:Field">Field</a></p></div><div class="subs instances"><p id="control.i:ToField" class="caption collapser" onclick="toggleSection('i:ToField')">Instances</p><div id="section.i:ToField" class="show"><table><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Char.html#t:Char">Char</a></td><td class="doc"><p>Uses UTF-8 encoding.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Double">Double</a></td><td class="doc"><p>Uses decimal notation or scientific notation, depending on the
 number.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Float">Float</a></td><td class="doc"><p>Uses decimal notation or scientific notation, depending on the
 number.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>Uses decimal encoding with optional sign.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int8">Int8</a></td><td class="doc"><p>Uses decimal encoding with optional sign.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int16">Int16</a></td><td class="doc"><p>Uses decimal encoding with optional sign.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int32">Int32</a></td><td class="doc"><p>Uses decimal encoding with optional sign.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Int.html#t:Int64">Int64</a></td><td class="doc"><p>Uses decimal encoding with optional sign.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Prelude.html#t:Integer">Integer</a></td><td class="doc"><p>Uses decimal encoding with optional sign.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Word.html#t:Word">Word</a></td><td class="doc"><p>Uses decimal encoding.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Word.html#t:Word8">Word8</a></td><td class="doc"><p>Uses decimal encoding.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Word.html#t:Word16">Word16</a></td><td class="doc"><p>Uses decimal encoding.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Word.html#t:Word32">Word32</a></td><td class="doc"><p>Uses decimal encoding.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> <a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Word.html#t:Word64">Word64</a></td><td class="doc"><p>Uses decimal encoding.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> ByteString</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> ByteString</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> <a href="file:///Users/horus/projects/haskell/csv/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/text-1.2.0.5/html/Data-Text-Lazy.html#t:Text">Text</a></td><td class="doc"><p>Uses UTF-8 encoding.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> <a href="file:///Users/horus/projects/haskell/csv/.cabal-sandbox/share/doc/x86_64-osx-ghc-7.8.3/text-1.2.0.5/html/Data-Text.html#t:Text">Text</a></td><td class="doc"><p>Uses UTF-8 encoding.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> [<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Char.html#t:Char">Char</a>]</td><td class="doc"><p>Uses UTF-8 encoding.</p></td></tr><tr><td class="src"><a href="Data-Csv.html#t:ToField">ToField</a> a =&gt; <a href="Data-Csv.html#t:ToField">ToField</a> (<a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#t:Maybe">Maybe</a> a)</td><td class="doc"><p><code><a href="file:///Users/horus/Library/Haskell/share/doc/ghc/html/libraries/base-4.7.0.1/Data-Maybe.html#v:Nothing">Nothing</a></code> is encoded as an <code>empty</code> field.</p></td></tr></table></div></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.14.3</p></div></body></html>